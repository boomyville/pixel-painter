<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boomy Pixel Painter</title>
    <style>
        :root { --accent: #e91e63; --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; }
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); padding: 20px; margin: 0; display: flex; flex-direction: column; align-items: center; }
        
        /* Modal Styles */
        #colorModal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); align-items: center; justify-content: center; }
        .modal-content { background: #222; padding: 25px; border-radius: 15px; border: 1px solid #444; display: flex; flex-direction: column; align-items: center; gap: 15px; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #wheel { cursor: crosshair; border-radius: 50%; box-shadow: 0 0 10px #000; }
        .modal-btns { display: flex; gap: 10px; width: 100%; }

        .hero-instructions { background: var(--panel); border-radius: 12px; padding: 15px; margin-bottom: 20px; width: 100%; max-width: 1000px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; border: 1px solid #333; }
        .inst-card h4 { margin: 0 0 5px 0; color: var(--accent); font-size: 0.8rem; text-transform: uppercase; }
        .inst-card p { margin: 0; font-size: 0.8rem; color: #bbb; }

        .controls { background: var(--panel); padding: 15px; border-radius: 12px; display: flex; flex-wrap: wrap; gap: 20px; align-items: center; margin-bottom: 15px; border: 1px solid #333; }
        
        .palette-container { display: flex; gap: 10px; align-items: center; background: #252525; padding: 10px 20px; border-radius: 50px; margin-bottom: 20px; border: 1px solid #333; }
        .swatch { width: 34px; height: 34px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: 0.2s; background: #333; }
        .swatch.active { border-color: white; box-shadow: 0 0 12px var(--accent); transform: scale(1.1); }
        .eraser-swatch { border: 2px dashed #ff4444; color: #ff4444; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; }

        #grid-container { overflow: auto; max-height: 55vh; max-width: 90vw; border: 2px solid #444; background: #000; border-radius: 4px; }
        #grid { display: grid; background: #1a1a1a; }
        .cell { width: 24px; height: 24px; border: 1px solid #222; box-sizing: border-box; }

        .layout { display: flex; flex-wrap: wrap; gap: 30px; justify-content: center; width: 100%; }
        .io-section { display: flex; flex-direction: column; gap: 10px; min-width: 420px; }
        
        textarea { width: 100%; height: 350px; background: #000; color: #0f0; font-family: 'Consolas', monospace; padding: 15px; border-radius: 8px; border: 1px solid #333; font-size: 0.8rem; resize: none; }
        button { padding: 10px 18px; border-radius: 6px; border: none; font-weight: bold; cursor: pointer; background: #333; color: white; }
        button.primary { background: var(--accent); }
    </style>
</head>
<body>

    <h2 style="margin-bottom: 15px;"-Boomy Pixel <span style="color: var(--accent)">Painter</span> v9</h2>

    <div class="hero-instructions">
        <div class="inst-card"><h4>Mouse</h4><p>Left: Paint | Right: Fill</p></div>
        <div class="inst-card"><h4>History</h4><p>Ctrl+Z: Undo | Ctrl+Y: Redo</p></div>
        <div class="inst-card"><h4>Picker</h4><p>Click the ðŸŒˆ button or current colour to open the wheel.</p></div>
    </div>

    <div class="controls">
        <label>Entity: <input type="text" id="entity_id" value="display_7b3db4" style="width: 120px; padding: 5px;"></label>
        <div style="display: flex; gap: 5px;">
            Size: <input type="number" id="grid_w" value="16" min="1" max="96" style="width: 45px;"> x 
            <input type="number" id="grid_h" value="16" min="1" max="96" style="width: 45px;">
        </div>
        <button class="primary" onclick="rebuildGrid()">Update Grid</button>
        <button onclick="openColorModal()" title="Open Color Wheel">ðŸŒˆ PICKER</button>
    </div>

    <div class="palette-container">
        <div id="palette" style="display: flex; gap: 8px;"></div>
        <div id="eraser" class="swatch eraser-swatch" onclick="setEraser()" title="Eraser Tool (X)">X</div>
        <div style="border-left: 1px solid #444; padding-left: 10px; display: flex; gap: 5px;">
            <button onclick="undo()">â†¶</button>
            <button onclick="redo()">â†·</button>
        </div>
    </div>

    <div id="colorModal">
        <div class="modal-content">
            <h3 style="margin: 0;">Select Color</h3>
            <canvas id="wheel" width="250" height="250"></canvas>
            <div id="selectedColorPreview" style="width: 100%; height: 30px; border-radius: 5px; border: 1px solid #fff;"></div>
            <div class="modal-btns">
                <button class="primary" onclick="closeColorModal(true)" style="flex: 1;">Apply</button>
                <button onclick="closeColorModal(false)" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <div class="layout">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <div id="grid-container">
                <div id="grid" oncontextmenu="return false;"></div>
            </div>
            <div id="hist-stat" style="font-size: 11px; color: #666; margin-top: 10px;">History: 1/50</div>
        </div>
        <div class="io-section">
            <div id="preview-container" style="display:none; margin-bottom: 10px; background: #222; padding: 10px; border-radius: 8px; text-align: center; border: 1px solid #333;">
                <div style="font-size: 0.8rem; color: #888; margin-bottom: 5px;">Imported Image</div>
                <img id="importedImage" style="max-width: 100%; max-height: 200px; image-rendering: pixelated; border: 1px solid #444;">
            </div>
            <label style="display:flex; align-items:center; gap:8px; font-size:0.9rem; margin-bottom:5px; cursor:pointer; color:#bbb;">
                <input type="checkbox" id="simpleOutput" onchange="generateYAML()"> Output Pixel Data Only
            </label>
            <textarea id="yaml-io" placeholder="YAML output / Import area..."></textarea>
            <div style="display: flex; gap: 10px;">
                <button class="primary" onclick="importYAML()" style="flex: 1;">Import YAML</button>
                <button onclick="copyToClipboard()" style="flex: 1;">Copy YAML</button>
                <button onclick="document.getElementById('pngInput').click()" style="background: #1976d2;">Import PNG</button>
                <button onclick="exportToPNG()" style="background: #2e7d32;">Export PNG</button>
            </div>
            <input type="file" id="pngInput" accept="image/png" style="display:none" onchange="importPNG(this)">
        </div>
    </div>

    <canvas id="exportCanvas" style="display:none;"></canvas>

    <script>
        const gridElement = document.getElementById('grid'), yamlTextArea = document.getElementById('yaml-io'), 
              entityInput = document.getElementById('entity_id'), paletteElement = document.getElementById('palette'),
              modal = document.getElementById('colorModal'), wheel = document.getElementById('wheel'), 
              ctxW = wheel.getContext('2d'), preview = document.getElementById('selectedColorPreview');
        
        let cells = [], currentColor = "#ffffff", tempColor = "#ffffff", isEraser = false, 
            activeColors = [], undoStack = [], redoStack = [];

        // Color Wheel Logic
        function drawWheel() {
            const radius = wheel.width / 2;
            for (let angle = 0; angle < 360; angle++) {
                const startAngle = (angle - 2) * Math.PI / 180;
                const endAngle = angle * Math.PI / 180;
                ctxW.beginPath();
                ctxW.moveTo(radius, radius);
                ctxW.arc(radius, radius, radius, startAngle, endAngle);
                ctxW.closePath();
                const gradient = ctxW.createRadialGradient(radius, radius, 0, radius, radius, radius);
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(1, `hsl(${angle}, 100%, 50%)`);
                ctxW.fillStyle = gradient;
                ctxW.fill();
            }
        }

        wheel.onclick = function(e) {
            const rect = wheel.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const imgData = ctxW.getImageData(x, y, 1, 1).data;
            tempColor = rgbToHex(imgData[0], imgData[1], imgData[2]);
            preview.style.backgroundColor = tempColor;
        };

        function openColorModal() { modal.style.display = 'flex'; preview.style.backgroundColor = currentColor; drawWheel(); }
        function closeColorModal(apply) { 
            modal.style.display = 'none'; 
            if (apply) manualColorPick(tempColor); 
        }

        // Standard Logic
        function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); }
        function hexToRgb(hex) {
            const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return res ? [parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16)] : [0,0,0];
        }

        function manualColorPick(val) {
            isEraser = false; currentColor = val;
            if (!activeColors.includes(val)) { activeColors.unshift(val); if (activeColors.length > 8) activeColors.pop(); }
            updatePaletteUI();
        }

        function rebuildGrid(wIn, hIn) {
            const w = wIn || Math.min(document.getElementById('grid_w').value, 96), h = hIn || Math.min(document.getElementById('grid_h').value, 96);
            gridElement.style.gridTemplateColumns = `repeat(${w}, 24px)`;
            gridElement.innerHTML = ''; cells = [];
            for (let y = 0; y < h; y++) {
                cells[y] = [];
                for (let x = 0; x < w; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell'; cell.dataset.x = x; cell.dataset.y = y;
                    cell.addEventListener('mousedown', (e) => { if (e.button === 0) paint(x, y); if (e.button === 2) { floodFill(x, y); finishAction(); } });
                    cell.addEventListener('mouseup', () => finishAction());
                    cell.addEventListener('mouseover', (e) => { if (e.buttons === 1) paint(x, y); });
                    gridElement.appendChild(cell); cells[y][x] = cell;
                }
            }
            undoStack = []; redoStack = []; scanCanvasColors(); saveHistory(); generateYAML();
        }

        function scanCanvasColors() {
            const found = new Set();
            cells.flat().forEach(c => { if(c.dataset.color) found.add(c.dataset.color); });
            activeColors = Array.from(found).slice(0, 8);
            const defs = ["#ffffff", "#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff", "#00ffff", "#ffa500"];
            while(activeColors.length < 8) {
                const n = defs.find(d => !activeColors.includes(d));
                if(!n) break; activeColors.push(n);
            }
            updatePaletteUI();
        }

        function updatePaletteUI() {
            paletteElement.innerHTML = '';
            activeColors.forEach(color => {
                const s = document.createElement('div');
                s.className = `swatch ${currentColor === color && !isEraser ? 'active' : ''}`;
                s.style.backgroundColor = color;
                s.onclick = () => { currentColor = color; isEraser = false; updatePaletteUI(); };
                paletteElement.appendChild(s);
            });
            document.getElementById('eraser').className = `swatch eraser-swatch ${isEraser ? 'active' : ''}`;
        }

        function finishAction() { scanCanvasColors(); saveHistory(); }
        function paint(x, y) {
            const cell = cells[y][x], col = isEraser ? '' : currentColor;
            if (cell.dataset.color === col) return;
            cell.style.backgroundColor = isEraser ? '#1a1a1a' : col;
            cell.dataset.color = col; generateYAML();
        }

        function floodFill(x, y) {
            const target = cells[y][x].dataset.color || '', fill = isEraser ? '' : currentColor;
            if (target === fill) return;
            const stack = [[x, y]];
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                if ((cells[cy][cx].dataset.color || '') === target) {
                    cells[cy][cx].style.backgroundColor = isEraser ? '#1a1a1a' : fill;
                    cells[cy][cx].dataset.color = fill;
                    if (cx > 0) stack.push([cx - 1, cy]);
                    if (cx < cells[0].length - 1) stack.push([cx + 1, cy]);
                    if (cy > 0) stack.push([cx, cy - 1]);
                    if (cy < cells.length - 1) stack.push([cx, cy + 1]);
                }
            }
            generateYAML();
        }

        function saveHistory() {
            const snap = JSON.stringify(cells.map(row => row.map(c => c.dataset.color || '')));
            if(undoStack.length > 0 && undoStack[undoStack.length-1] === snap) return;
            undoStack.push(snap); if (undoStack.length > 50) undoStack.shift();
            redoStack = []; document.getElementById('hist-stat').innerText = `History: ${undoStack.length}/50`;
        }

        function undo() { if (undoStack.length <= 1) return; redoStack.push(undoStack.pop()); applySnapshot(undoStack[undoStack.length - 1]); }
        function redo() { if (redoStack.length === 0) return; const snap = redoStack.pop(); undoStack.push(snap); applySnapshot(snap); }
        function applySnapshot(snap) {
            JSON.parse(snap).forEach((row, y) => row.forEach((col, x) => {
                cells[y][x].dataset.color = col; cells[y][x].style.backgroundColor = col === '' ? '#1a1a1a' : col;
            }));
            scanCanvasColors(); generateYAML();
        }

        function generateYAML() {
            const simple = document.getElementById('simpleOutput') && document.getElementById('simpleOutput').checked;
            let yaml = '';
            if (!simple) {
                yaml += `target:\n  entity_id: light.${entityInput.value}\ndata:\n  elements:\n`;
            }
            yaml += `    - type: pixels\n      pixels:\n`;
            cells.flat().forEach(c => { if (c.dataset.color) { const rgb = hexToRgb(c.dataset.color); yaml += `        - [${c.dataset.x}, ${c.dataset.y}, ${rgb[0]}, ${rgb[1]}, ${rgb[2]}]\n`; } });
            
            if (!simple) {
                yaml += `action: ump.draw_visuals`; 
            }
            yamlTextArea.value = yaml;
        }

        function importYAML() {
            try {
                const val = yamlTextArea.value, m = val.match(/pixels:\s*([\s\S]*?)(?=\s*type:|\s*action:|$)/);
                if (!m) throw new Error("No pixels found");
                const pix = []; let mW = 0, mH = 0;
                m[1].trim().split('\n').forEach(l => {
                    const match = l.match(/\[\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\]/);
                    if (match) { const [_, x, y, r, g, b] = match.map(Number); pix.push({x, y, h: rgbToHex(r,g,b)}); if (x > mW) mW = x; if (y > mH) mH = y; }
                });
                document.getElementById('grid_w').value = mW + 1; document.getElementById('grid_h').value = mH + 1;
                rebuildGrid(mW + 1, mH + 1);
                pix.forEach(p => { cells[p.y][p.x].style.backgroundColor = p.h; cells[p.y][p.x].dataset.color = p.h; });
                finishAction(); generateYAML();
            } catch (e) { alert(e.message); }
        }

        function importPNG(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const pContainer = document.getElementById('preview-container');
                    const pImg = document.getElementById('importedImage');
                    if(pContainer && pImg) {
                        pImg.src = e.target.result;
                        pContainer.style.display = 'block';
                    }

                    const img = new Image();
                    // Add crossOrigin to prevent "tainted canvas" errors
                    img.crossOrigin = "Anonymous"; 
                    
                    img.onload = function() {
                        let w = img.width;
                        let h = img.height;
                        
                        const MAX_SIZE = 64;
                        if (w > MAX_SIZE || h > MAX_SIZE) {
                            const ratio = Math.min(MAX_SIZE / w, MAX_SIZE / h);
                            w = Math.floor(w * ratio);
                            h = Math.floor(h * ratio);
                        }

                        w = Math.max(1, w);
                        h = Math.max(1, h);

                        document.getElementById('grid_w').value = w;
                        document.getElementById('grid_h').value = h;
                        
                        // Rebuild grid FIRST
                        rebuildGrid(w, h);

                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        
                        ctx.imageSmoothingEnabled = false; 
                        ctx.drawImage(img, 0, 0, w, h); 
                        
                        try {
                            const imgData = ctx.getImageData(0, 0, w, h);
                            const data = imgData.data;

                            for (let y = 0; y < h; y++) {
                                for (let x = 0; x < w; x++) {
                                    const i = (y * w + x) * 4;
                                    const r = data[i];
                                    const g = data[i + 1];
                                    const b = data[i + 2];
                                    const a = data[i + 3];

                                    // Only paint pixels that aren't fully transparent
                                    if (a > 50) { 
                                        const hex = rgbToHex(r, g, b);
                                        if (cells[y] && cells[y][x]) {
                                            cells[y][x].style.backgroundColor = hex;
                                            cells[y][x].dataset.color = hex;
                                        }
                                    }
                                }
                            }
                            finishAction();
                            generateYAML();
                        } catch (err) {
                            console.error("Canvas read error:", err);
                            alert("Could not read image data. Try a smaller PNG or a different browser.");
                        }
                        input.value = ''; 
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

        function exportToPNG() {
            const w = cells[0].length, h = cells.length, c = document.getElementById('exportCanvas'), ctx = c.getContext('2d');
            c.width = w; c.height = h; ctx.clearRect(0,0,w,h);
            cells.forEach((r,y)=>r.forEach((cell,x)=>{ if(cell.dataset.color){ctx.fillStyle=cell.dataset.color;ctx.fillRect(x,y,1,1);}}));
            const a = document.createElement('a'); a.download = `matrix-${Date.now()}.png`; a.href = c.toDataURL(); a.click();
        }

        function setEraser() { isEraser = true; updatePaletteUI(); }
        function copyToClipboard() { yamlTextArea.select(); document.execCommand('copy'); }
        window.addEventListener('keydown', (e) => { 
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); } 
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
            if (e.key === 'x') setEraser(); 
        });

        rebuildGrid();
    </script>
</body>
</html>
